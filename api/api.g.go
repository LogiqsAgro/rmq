// Code generated by go generate; DO NOT EDIT.
//
// last generated at 2021-12-12T19:07:12+01:00
//
package api

import (
	"fmt"
	"net/http"
	"net/url"
)

//RabbitMQVersion show the version against which this api was generated
func RabbitMQVersion() string { return "3.9.5" }

// Various random bits of information that describe the whole
// system.
// GET /api/overview
func GetOverview() Builder {
	path := "/api/overview"
	return Request().Method(http.MethodGet).Path(path)
}

// Name identifying this RabbitMQ cluster.
// GET /api/cluster-name
func GetClusterName() Builder {
	path := "/api/cluster-name"
	return Request().Method(http.MethodGet).Path(path)
}

// Name identifying this RabbitMQ cluster.
// PUT /api/cluster-name
func PutClusterName() Builder {
	path := "/api/cluster-name"
	return Request().Method(http.MethodPut).Path(path)
}

// A list of nodes in the RabbitMQ cluster.
// GET /api/nodes
func GetNodes() Builder {
	path := "/api/nodes"
	return Request().Method(http.MethodGet).Path(path)
}

// An individual node in the RabbitMQ cluster. Add
// "?memory=true" to get memory statistics, and "?binary=true"
// to get a breakdown of binary memory use (may be expensive if
// there are many small binaries in the system).
// GET /api/nodes/{name}
func GetNode(name string) Builder {
	path := fmt.Sprintf("/api/nodes/%v", url.PathEscape(name))
	return Request().Method(http.MethodGet).Path(path)
}

// A list of extensions to the management plugin.
// GET /api/extensions
func GetExtensions() Builder {
	path := "/api/extensions"
	return Request().Method(http.MethodGet).Path(path)
}

// The server definitions - exchanges, queues, bindings, users,
// virtual hosts, permissions, topic permissions, and parameters. Everything apart from
// messages. POST to upload an existing set of definitions. Note
// that:
// The definitions are merged. Anything already existing on
// the server but not in the uploaded definitions is
// untouched.
// Conflicting definitions on immutable objects (exchanges,
// queues and bindings) will be ignored. The existing definition
// will be preserved.
// Conflicting definitions on mutable objects will cause
// the object in the server to be overwritten with the
// object from the definitions.
// In the event of an error you will be left with a
// part-applied set of definitions.
// For convenience you may upload a file from a browser to this
// URI (i.e. you can use multipart/form-data as
// well as application/json) in which case the
// definitions should be uploaded as a form field named
// "file".
// GET /api/definitions
func GetDefinitions() Builder {
	path := "/api/definitions"
	return Request().Method(http.MethodGet).Path(path)
}

// The server definitions - exchanges, queues, bindings, users,
// virtual hosts, permissions, topic permissions, and parameters. Everything apart from
// messages. POST to upload an existing set of definitions. Note
// that:
// The definitions are merged. Anything already existing on
// the server but not in the uploaded definitions is
// untouched.
// Conflicting definitions on immutable objects (exchanges,
// queues and bindings) will be ignored. The existing definition
// will be preserved.
// Conflicting definitions on mutable objects will cause
// the object in the server to be overwritten with the
// object from the definitions.
// In the event of an error you will be left with a
// part-applied set of definitions.
// For convenience you may upload a file from a browser to this
// URI (i.e. you can use multipart/form-data as
// well as application/json) in which case the
// definitions should be uploaded as a form field named
// "file".
// POST /api/definitions
func PostDefinitions() Builder {
	path := "/api/definitions"
	return Request().Method(http.MethodPost).Path(path)
}

// (deprecated) The server definitions - exchanges, queues, bindings, users,
// virtual hosts, permissions, topic permissions, and parameters. Everything apart from
// messages. POST to upload an existing set of definitions. Note
// that:
// The definitions are merged. Anything already existing on
// the server but not in the uploaded definitions is
// untouched.
// Conflicting definitions on immutable objects (exchanges,
// queues and bindings) will be ignored. The existing definition
// will be preserved.
// Conflicting definitions on mutable objects will cause
// the object in the server to be overwritten with the
// object from the definitions.
// In the event of an error you will be left with a
// part-applied set of definitions.
// For convenience you may upload a file from a browser to this
// URI (i.e. you can use multipart/form-data as
// well as application/json) in which case the
// definitions should be uploaded as a form field named
// "file".
// GET /api/all-configuration
func GetAllConfiguration() Builder {
	path := "/api/all-configuration"
	return Request().Method(http.MethodGet).Path(path)
}

// (deprecated) The server definitions - exchanges, queues, bindings, users,
// virtual hosts, permissions, topic permissions, and parameters. Everything apart from
// messages. POST to upload an existing set of definitions. Note
// that:
// The definitions are merged. Anything already existing on
// the server but not in the uploaded definitions is
// untouched.
// Conflicting definitions on immutable objects (exchanges,
// queues and bindings) will be ignored. The existing definition
// will be preserved.
// Conflicting definitions on mutable objects will cause
// the object in the server to be overwritten with the
// object from the definitions.
// In the event of an error you will be left with a
// part-applied set of definitions.
// For convenience you may upload a file from a browser to this
// URI (i.e. you can use multipart/form-data as
// well as application/json) in which case the
// definitions should be uploaded as a form field named
// "file".
// POST /api/all-configuration
func PostAllConfiguration() Builder {
	path := "/api/all-configuration"
	return Request().Method(http.MethodPost).Path(path)
}

// The server definitions for a given virtual host -
// exchanges, queues, bindings and policies.
// POST to upload an existing set of definitions. Note that:
// The definitions are merged. Anything already existing on
// the server but not in the uploaded definitions is
// untouched.
// Conflicting definitions on immutable objects (exchanges,
// queues and bindings) will be ignored. The existing definition
// will be preserved.
// Conflicting definitions on mutable objects will cause
// the object in the server to be overwritten with the
// object from the definitions.
// In the event of an error you will be left with a
// part-applied set of definitions.
// For convenience you may upload a file from a browser to this
// URI (i.e. you can use multipart/form-data as
// well as application/json) in which case the
// definitions should be uploaded as a form field named
// "file".
// GET /api/definitions/{vhost}
func GetDefinitionsForVhost(vhost string) Builder {
	path := fmt.Sprintf("/api/definitions/%v", url.PathEscape(vhost))
	return Request().Method(http.MethodGet).Path(path)
}

// The server definitions for a given virtual host -
// exchanges, queues, bindings and policies.
// POST to upload an existing set of definitions. Note that:
// The definitions are merged. Anything already existing on
// the server but not in the uploaded definitions is
// untouched.
// Conflicting definitions on immutable objects (exchanges,
// queues and bindings) will be ignored. The existing definition
// will be preserved.
// Conflicting definitions on mutable objects will cause
// the object in the server to be overwritten with the
// object from the definitions.
// In the event of an error you will be left with a
// part-applied set of definitions.
// For convenience you may upload a file from a browser to this
// URI (i.e. you can use multipart/form-data as
// well as application/json) in which case the
// definitions should be uploaded as a form field named
// "file".
// POST /api/definitions/{vhost}
func PostDefinitionsForVhost(vhost string) Builder {
	path := fmt.Sprintf("/api/definitions/%v", url.PathEscape(vhost))
	return Request().Method(http.MethodPost).Path(path)
}

// A list of all open connections. Use pagination parameters to filter connections.
// GET /api/connections
func GetConnections() Builder {
	path := "/api/connections"
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all open connections in a specific virtual host. Use pagination parameters to filter connections.
// GET /api/vhosts/{vhost}/connections
func GetConnectionsForVhost(vhost string) Builder {
	path := fmt.Sprintf("/api/vhosts/%v/connections", url.PathEscape(vhost))
	return Request().Method(http.MethodGet).Path(path)
}

// An individual connection. DELETEing it will close the
// connection. Optionally set the "X-Reason" header when
// DELETEing to provide a reason.
// GET /api/connections/{name}
func GetConnection(name string) Builder {
	path := fmt.Sprintf("/api/connections/%v", url.PathEscape(name))
	return Request().Method(http.MethodGet).Path(path)
}

// An individual connection. DELETEing it will close the
// connection. Optionally set the "X-Reason" header when
// DELETEing to provide a reason.
// DELETE /api/connections/{name}
func DeleteConnection(name string) Builder {
	path := fmt.Sprintf("/api/connections/%v", url.PathEscape(name))
	return Request().Method(http.MethodDelete).Path(path)
}

// List of all channels for a given connection.
// GET /api/connections/{name}/channels
func GetConnectionChannels(name string) Builder {
	path := fmt.Sprintf("/api/connections/%v/channels", url.PathEscape(name))
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all open channels. Use pagination parameters to filter channels.
// GET /api/channels
func GetChannels() Builder {
	path := "/api/channels"
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all open channels in a specific virtual host. Use pagination parameters to filter channels.
// GET /api/vhosts/{vhost}/channels
func GetChannelsForVhost(vhost string) Builder {
	path := fmt.Sprintf("/api/vhosts/%v/channels", url.PathEscape(vhost))
	return Request().Method(http.MethodGet).Path(path)
}

// Details about an individual channel.
// GET /api/channels/{channel}
func GetChannel(channel string) Builder {
	path := fmt.Sprintf("/api/channels/%v", url.PathEscape(channel))
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all consumers.
// GET /api/consumers
func GetConsumers() Builder {
	path := "/api/consumers"
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all consumers in a given virtual host.
// GET /api/consumers/{vhost}
func GetConsumersForVhost(vhost string) Builder {
	path := fmt.Sprintf("/api/consumers/%v", url.PathEscape(vhost))
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all exchanges. Use pagination parameters to filter exchanges.
// GET /api/exchanges
func GetExchanges() Builder {
	path := "/api/exchanges"
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all exchanges in a given virtual host. Use pagination parameters to filter exchanges.
// GET /api/exchanges/{vhost}
func GetExchangesForVhost(vhost string) Builder {
	path := fmt.Sprintf("/api/exchanges/%v", url.PathEscape(vhost))
	return Request().Method(http.MethodGet).Path(path)
}

// An individual exchange. To PUT an exchange, you will need a body looking something like this:
// {"type":"direct","auto_delete":false,"durable":true,"internal":false,"arguments":{}}
// The type key is mandatory; other keys are optional.
// When DELETEing an exchange you can add the query string
// parameter if-unused=true. This prevents the
// delete from succeeding if the exchange is bound to a queue
// or as a source to another exchange.
// GET /api/exchanges/{vhost}/{name}
func GetExchangeForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/exchanges/%v/%v", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodGet).Path(path)
}

// An individual exchange. To PUT an exchange, you will need a body looking something like this:
// {"type":"direct","auto_delete":false,"durable":true,"internal":false,"arguments":{}}
// The type key is mandatory; other keys are optional.
// When DELETEing an exchange you can add the query string
// parameter if-unused=true. This prevents the
// delete from succeeding if the exchange is bound to a queue
// or as a source to another exchange.
// PUT /api/exchanges/{vhost}/{name}
func PutExchangeForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/exchanges/%v/%v", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodPut).Path(path)
}

// An individual exchange. To PUT an exchange, you will need a body looking something like this:
// {"type":"direct","auto_delete":false,"durable":true,"internal":false,"arguments":{}}
// The type key is mandatory; other keys are optional.
// When DELETEing an exchange you can add the query string
// parameter if-unused=true. This prevents the
// delete from succeeding if the exchange is bound to a queue
// or as a source to another exchange.
// DELETE /api/exchanges/{vhost}/{name}
func DeleteExchangeForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/exchanges/%v/%v", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodDelete).Path(path)
}

// A list of all bindings in which a given exchange is the source.
// GET /api/exchanges/{vhost}/{name}/bindings/source
func GetExchangeBindingsSourceForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/exchanges/%v/%v/bindings/source", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all bindings in which a given exchange is the destination.
// GET /api/exchanges/{vhost}/{name}/bindings/destination
func GetExchangeBindingsDestinationForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/exchanges/%v/%v/bindings/destination", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodGet).Path(path)
}

// Publish a message to a given exchange. You will need a body
// looking something like:
// {"properties":{},"routing_key":"my key","payload":"my body","payload_encoding":"string"}
// All keys are mandatory. The payload_encoding
// key should be either "string" (in which case the payload
// will be taken to be the UTF-8 encoding of the payload field)
// or "base64" (in which case the payload field is taken to be
// base64 encoded).
// If the message is published successfully, the response will
// look like:
// {"routed": true}
// routed will be true if the message was sent to
// at least one queue.
// Please note that the HTTP API is not ideal for high
// performance publishing; the need to create a new TCP
// connection for each message published can limit message
// throughput compared to AMQP or other protocols using
// long-lived connections.
// POST /api/exchanges/{vhost}/{name}/publish
func PostExchangePublishForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/exchanges/%v/%v/publish", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodPost).Path(path)
}

// A list of all queues. Use pagination parameters to filter queues.
// GET /api/queues
func GetQueues() Builder {
	path := "/api/queues"
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all queues in a given virtual host. Use pagination parameters to filter queues.
// GET /api/queues/{vhost}
func GetQueuesForVhost(vhost string) Builder {
	path := fmt.Sprintf("/api/queues/%v", url.PathEscape(vhost))
	return Request().Method(http.MethodGet).Path(path)
}

// An individual queue. To PUT a queue, you will need a body looking something like this:
// {"auto_delete":false,"durable":true,"arguments":{},"node":"rabbit@smacmullen"}
// All keys are optional.
// When DELETEing a queue you can add the query string
// parameters if-empty=true and /
// or if-unused=true. These prevent the delete
// from succeeding if the queue contains messages, or has
// consumers, respectively.
// GET /api/queues/{vhost}/{name}
func GetQueueForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/queues/%v/%v", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodGet).Path(path)
}

// An individual queue. To PUT a queue, you will need a body looking something like this:
// {"auto_delete":false,"durable":true,"arguments":{},"node":"rabbit@smacmullen"}
// All keys are optional.
// When DELETEing a queue you can add the query string
// parameters if-empty=true and /
// or if-unused=true. These prevent the delete
// from succeeding if the queue contains messages, or has
// consumers, respectively.
// PUT /api/queues/{vhost}/{name}
func PutQueueForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/queues/%v/%v", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodPut).Path(path)
}

// An individual queue. To PUT a queue, you will need a body looking something like this:
// {"auto_delete":false,"durable":true,"arguments":{},"node":"rabbit@smacmullen"}
// All keys are optional.
// When DELETEing a queue you can add the query string
// parameters if-empty=true and /
// or if-unused=true. These prevent the delete
// from succeeding if the queue contains messages, or has
// consumers, respectively.
// DELETE /api/queues/{vhost}/{name}
func DeleteQueueForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/queues/%v/%v", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodDelete).Path(path)
}

// A list of all bindings on a given queue.
// GET /api/queues/{vhost}/{name}/bindings
func GetQueueBindingsForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/queues/%v/%v/bindings", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodGet).Path(path)
}

// Contents of a queue. DELETE to purge. Note you can't GET this.
// DELETE /api/queues/{vhost}/{name}/contents
func DeleteQueueContentsForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/queues/%v/%v/contents", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodDelete).Path(path)
}

// Actions that can be taken on a queue. POST a body like:
// {"action":"sync"} Currently the actions which are
// supported are sync and cancel_sync.
// POST /api/queues/{vhost}/{name}/actions
func PostQueueActionsForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/queues/%v/%v/actions", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodPost).Path(path)
}

// Get messages from a queue. (This is not an HTTP GET as it
// will alter the state of the queue.) You should post a body looking like:
// {"count":5,"ackmode":"ack_requeue_true","encoding":"auto","truncate":50000}
// count controls the maximum number of
// messages to get. You may get fewer messages than this if
// the queue cannot immediately provide them.
// ackmode determines whether the messages will be
// removed from the queue. If ackmode is ack_requeue_true or reject_requeue_true they will be requeued -
// if ackmode is ack_requeue_false or reject_requeue_false they will be removed.
// encoding must be either "auto" (in which case the
// payload will be returned as a string if it is valid UTF-8, and
// base64 encoded otherwise), or "base64" (in which case the payload
// will always be base64 encoded).
// If truncate is present it will truncate the
// message payload if it is larger than the size given (in bytes).
// truncate is optional; all other keys are mandatory.
// Please note that the get path in the HTTP API is intended
// for diagnostics etc - it does not implement reliable
// delivery and so should be treated as a sysadmin's tool
// rather than a general API for messaging.
// POST /api/queues/{vhost}/{name}/get
func PostQueueGetForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/queues/%v/%v/get", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodPost).Path(path)
}

// A list of all bindings.
// GET /api/bindings
func GetBindings() Builder {
	path := "/api/bindings"
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all bindings in a given virtual host.
// GET /api/bindings/{vhost}
func GetBindingsForVhost(vhost string) Builder {
	path := fmt.Sprintf("/api/bindings/%v", url.PathEscape(vhost))
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all bindings between an exchange and a
// queue. Remember, an exchange and a queue can be bound
// together many times!
// To create a new binding, POST to this
// URI. Request body should be a JSON object optionally containing
// two fields, routing_key (a string) and arguments (a map of optional arguments):
// {"routing_key":"my_routing_key", "arguments":{"x-arg": "value"}}
// All keys are optional.
// The response will contain a Location header
// telling you the URI of your new binding.
// GET /api/bindings/{vhost}/e/{exchange}/q/{queue}
func GetBindingsEQForVhostAndExchangeAndQueue(vhost string, exchange string, queue string) Builder {
	path := fmt.Sprintf("/api/bindings/%v/e/%v/q/%v", url.PathEscape(vhost), url.PathEscape(exchange), url.PathEscape(queue))
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all bindings between an exchange and a
// queue. Remember, an exchange and a queue can be bound
// together many times!
// To create a new binding, POST to this
// URI. Request body should be a JSON object optionally containing
// two fields, routing_key (a string) and arguments (a map of optional arguments):
// {"routing_key":"my_routing_key", "arguments":{"x-arg": "value"}}
// All keys are optional.
// The response will contain a Location header
// telling you the URI of your new binding.
// POST /api/bindings/{vhost}/e/{exchange}/q/{queue}
func PostBindingsEQForVhostAndExchangeAndQueue(vhost string, exchange string, queue string) Builder {
	path := fmt.Sprintf("/api/bindings/%v/e/%v/q/%v", url.PathEscape(vhost), url.PathEscape(exchange), url.PathEscape(queue))
	return Request().Method(http.MethodPost).Path(path)
}

// An individual binding between an exchange and a queue.
// The {props} part of the URI is a "name" for the binding
// composed of its routing key and a hash of its
// arguments. {props} is the field named "properties_key"
// from a bindings listing response.
// GET /api/bindings/{vhost}/e/{exchange}/q/{queue}/{props}
func GetBindingsEQForVhostAndExchangeAndQueueAndProps(vhost string, exchange string, queue string, props string) Builder {
	path := fmt.Sprintf("/api/bindings/%v/e/%v/q/%v/%v", url.PathEscape(vhost), url.PathEscape(exchange), url.PathEscape(queue), url.PathEscape(props))
	return Request().Method(http.MethodGet).Path(path)
}

// An individual binding between an exchange and a queue.
// The {props} part of the URI is a "name" for the binding
// composed of its routing key and a hash of its
// arguments. {props} is the field named "properties_key"
// from a bindings listing response.
// DELETE /api/bindings/{vhost}/e/{exchange}/q/{queue}/{props}
func DeleteBindingsEQForVhostAndExchangeAndQueueAndProps(vhost string, exchange string, queue string, props string) Builder {
	path := fmt.Sprintf("/api/bindings/%v/e/%v/q/%v/%v", url.PathEscape(vhost), url.PathEscape(exchange), url.PathEscape(queue), url.PathEscape(props))
	return Request().Method(http.MethodDelete).Path(path)
}

// A list of all bindings between two exchanges, similar to
// the list of all bindings between an exchange and a queue,
// above.
// To create a new binding, POST to this
// URI. Request body should be a JSON object optionally containing
// two fields, routing_key (a string) and arguments (a map of optional arguments):
// {"routing_key":"my_routing_key", "arguments":{"x-arg": "value"}}
// All keys are optional.
// The response will contain a Location header
// telling you the URI of your new binding.
// GET /api/bindings/{vhost}/e/{source}/e/{destination}
func GetBindingsEEForVhostAndSourceAndDestination(vhost string, source string, destination string) Builder {
	path := fmt.Sprintf("/api/bindings/%v/e/%v/e/%v", url.PathEscape(vhost), url.PathEscape(source), url.PathEscape(destination))
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all bindings between two exchanges, similar to
// the list of all bindings between an exchange and a queue,
// above.
// To create a new binding, POST to this
// URI. Request body should be a JSON object optionally containing
// two fields, routing_key (a string) and arguments (a map of optional arguments):
// {"routing_key":"my_routing_key", "arguments":{"x-arg": "value"}}
// All keys are optional.
// The response will contain a Location header
// telling you the URI of your new binding.
// POST /api/bindings/{vhost}/e/{source}/e/{destination}
func PostBindingsEEForVhostAndSourceAndDestination(vhost string, source string, destination string) Builder {
	path := fmt.Sprintf("/api/bindings/%v/e/%v/e/%v", url.PathEscape(vhost), url.PathEscape(source), url.PathEscape(destination))
	return Request().Method(http.MethodPost).Path(path)
}

// An individual binding between two exchanges. Similar to
// the individual binding between an exchange and a queue,
// above.
// GET /api/bindings/{vhost}/e/{source}/e/{destination}/{props}
func GetBindingsEEForVhostAndSourceAndDestinationAndProps(vhost string, source string, destination string, props string) Builder {
	path := fmt.Sprintf("/api/bindings/%v/e/%v/e/%v/%v", url.PathEscape(vhost), url.PathEscape(source), url.PathEscape(destination), url.PathEscape(props))
	return Request().Method(http.MethodGet).Path(path)
}

// An individual binding between two exchanges. Similar to
// the individual binding between an exchange and a queue,
// above.
// DELETE /api/bindings/{vhost}/e/{source}/e/{destination}/{props}
func DeleteBindingsEEForVhostAndSourceAndDestinationAndProps(vhost string, source string, destination string, props string) Builder {
	path := fmt.Sprintf("/api/bindings/%v/e/%v/e/%v/%v", url.PathEscape(vhost), url.PathEscape(source), url.PathEscape(destination), url.PathEscape(props))
	return Request().Method(http.MethodDelete).Path(path)
}

// A list of all vhosts.
// GET /api/vhosts
func GetVhosts() Builder {
	path := "/api/vhosts"
	return Request().Method(http.MethodGet).Path(path)
}

// An individual virtual host. As a virtual host usually only
// has a name, you do not need an HTTP body when PUTing one of
// these. To set metadata on creation, provide a body like the following:
// {"description":"virtual host description", "tags":"accounts,production"}
// tags is a comma-separated list of tags.
// These metadata fields are optional.
// To enable / disable tracing, provide a body looking like:
// {"tracing":true}
// GET /api/vhosts/{name}
func GetVhost(name string) Builder {
	path := fmt.Sprintf("/api/vhosts/%v", url.PathEscape(name))
	return Request().Method(http.MethodGet).Path(path)
}

// An individual virtual host. As a virtual host usually only
// has a name, you do not need an HTTP body when PUTing one of
// these. To set metadata on creation, provide a body like the following:
// {"description":"virtual host description", "tags":"accounts,production"}
// tags is a comma-separated list of tags.
// These metadata fields are optional.
// To enable / disable tracing, provide a body looking like:
// {"tracing":true}
// PUT /api/vhosts/{name}
func PutVhost(name string) Builder {
	path := fmt.Sprintf("/api/vhosts/%v", url.PathEscape(name))
	return Request().Method(http.MethodPut).Path(path)
}

// An individual virtual host. As a virtual host usually only
// has a name, you do not need an HTTP body when PUTing one of
// these. To set metadata on creation, provide a body like the following:
// {"description":"virtual host description", "tags":"accounts,production"}
// tags is a comma-separated list of tags.
// These metadata fields are optional.
// To enable / disable tracing, provide a body looking like:
// {"tracing":true}
// DELETE /api/vhosts/{name}
func DeleteVhost(name string) Builder {
	path := fmt.Sprintf("/api/vhosts/%v", url.PathEscape(name))
	return Request().Method(http.MethodDelete).Path(path)
}

// A list of all permissions for a given virtual host.
// GET /api/vhosts/{name}/permissions
func GetVhostPermissions(name string) Builder {
	path := fmt.Sprintf("/api/vhosts/%v/permissions", url.PathEscape(name))
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all topic permissions for a given virtual host.
// GET /api/vhosts/{name}/topic-permissions
func GetVhostTopicPermissions(name string) Builder {
	path := fmt.Sprintf("/api/vhosts/%v/topic-permissions", url.PathEscape(name))
	return Request().Method(http.MethodGet).Path(path)
}

// Starts virtual host {name} on node {node}.
// POST /api/vhosts/{name}/start/{node}
func PostVhostStartForNode(name string, node string) Builder {
	path := fmt.Sprintf("/api/vhosts/%v/start/%v", url.PathEscape(name), url.PathEscape(node))
	return Request().Method(http.MethodPost).Path(path)
}

// A list of all users.
// GET /api/users/
func GetUsers() Builder {
	path := "/api/users/"
	return Request().Method(http.MethodGet).Path(path)
}

// A list of users that do not have access to any virtual host.
// GET /api/users/without-permissions
func GetUsersWithoutPermissions() Builder {
	path := "/api/users/without-permissions"
	return Request().Method(http.MethodGet).Path(path)
}

// Bulk deletes a list of users. Request body must contain the list:
// {"users" : ["user1", "user2", "user3"]}
// POST /api/users/bulk-delete
func PostUsersBulkDelete() Builder {
	path := "/api/users/bulk-delete"
	return Request().Method(http.MethodPost).Path(path)
}

// An individual user. To PUT a user, you will need a body looking something like this:
// {"password":"secret","tags":"administrator"}
// or:
// {"password_hash":"2lmoth8l4H0DViLaK9Fxi6l9ds8=", "tags":"administrator"}
// The tags key is mandatory. Either
// password or password_hash
// can be set. If neither are set the user will not be able to log in with a password,
// but other mechanisms like client certificates may be used.
// Setting password_hash to "" will ensure the
// user cannot use a password to log in. tags is a
// comma-separated list of tags for the user. Currently recognised tags
// are administrator, monitoring and management.
// password_hash must be generated using the algorithm described
// here.
// You may also specify the hash function being used by adding the hashing_algorithm
// key to the body. Currently recognised algorithms are rabbit_password_hashing_sha256,
// rabbit_password_hashing_sha512, and rabbit_password_hashing_md5.
// GET /api/users/{name}
func GetUser(name string) Builder {
	path := fmt.Sprintf("/api/users/%v", url.PathEscape(name))
	return Request().Method(http.MethodGet).Path(path)
}

// An individual user. To PUT a user, you will need a body looking something like this:
// {"password":"secret","tags":"administrator"}
// or:
// {"password_hash":"2lmoth8l4H0DViLaK9Fxi6l9ds8=", "tags":"administrator"}
// The tags key is mandatory. Either
// password or password_hash
// can be set. If neither are set the user will not be able to log in with a password,
// but other mechanisms like client certificates may be used.
// Setting password_hash to "" will ensure the
// user cannot use a password to log in. tags is a
// comma-separated list of tags for the user. Currently recognised tags
// are administrator, monitoring and management.
// password_hash must be generated using the algorithm described
// here.
// You may also specify the hash function being used by adding the hashing_algorithm
// key to the body. Currently recognised algorithms are rabbit_password_hashing_sha256,
// rabbit_password_hashing_sha512, and rabbit_password_hashing_md5.
// PUT /api/users/{name}
func PutUser(name string) Builder {
	path := fmt.Sprintf("/api/users/%v", url.PathEscape(name))
	return Request().Method(http.MethodPut).Path(path)
}

// An individual user. To PUT a user, you will need a body looking something like this:
// {"password":"secret","tags":"administrator"}
// or:
// {"password_hash":"2lmoth8l4H0DViLaK9Fxi6l9ds8=", "tags":"administrator"}
// The tags key is mandatory. Either
// password or password_hash
// can be set. If neither are set the user will not be able to log in with a password,
// but other mechanisms like client certificates may be used.
// Setting password_hash to "" will ensure the
// user cannot use a password to log in. tags is a
// comma-separated list of tags for the user. Currently recognised tags
// are administrator, monitoring and management.
// password_hash must be generated using the algorithm described
// here.
// You may also specify the hash function being used by adding the hashing_algorithm
// key to the body. Currently recognised algorithms are rabbit_password_hashing_sha256,
// rabbit_password_hashing_sha512, and rabbit_password_hashing_md5.
// DELETE /api/users/{name}
func DeleteUser(name string) Builder {
	path := fmt.Sprintf("/api/users/%v", url.PathEscape(name))
	return Request().Method(http.MethodDelete).Path(path)
}

// A list of all permissions for a given user.
// GET /api/users/{user}/permissions
func GetUsersPermissions(user string) Builder {
	path := fmt.Sprintf("/api/users/%v/permissions", url.PathEscape(user))
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all topic permissions for a given user.
// GET /api/users/{user}/topic-permissions
func GetUsersTopicPermissions(user string) Builder {
	path := fmt.Sprintf("/api/users/%v/topic-permissions", url.PathEscape(user))
	return Request().Method(http.MethodGet).Path(path)
}

// Lists per-user limits for all users.
// GET /api/user-limits
func GetUserLimits() Builder {
	path := "/api/user-limits"
	return Request().Method(http.MethodGet).Path(path)
}

// Lists per-user limits for a specific user.
// GET /api/user-limits/{user}
func GetUserLimits2(user string) Builder {
	path := fmt.Sprintf("/api/user-limits/%v", url.PathEscape(user))
	return Request().Method(http.MethodGet).Path(path)
}

// Set or delete per-user limit for user. The name URL path element
// refers to the name of the limit (max-connections, max-channels).
// Limits are set using a JSON document in the body: {"value": 100}. Example
// request:
// curl -4u 'guest:guest' -H 'content-type:application/json' -X PUT localhost:15672/api/user-limits/guest/max-connections -d '{"value": 50}'
// PUT /api/user-limits/{user}/{name}
func PutUserLimitForUser(user string, name string) Builder {
	path := fmt.Sprintf("/api/user-limits/%v/%v", url.PathEscape(user), url.PathEscape(name))
	return Request().Method(http.MethodPut).Path(path)
}

// Set or delete per-user limit for user. The name URL path element
// refers to the name of the limit (max-connections, max-channels).
// Limits are set using a JSON document in the body: {"value": 100}. Example
// request:
// curl -4u 'guest:guest' -H 'content-type:application/json' -X PUT localhost:15672/api/user-limits/guest/max-connections -d '{"value": 50}'
// DELETE /api/user-limits/{user}/{name}
func DeleteUserLimitForUser(user string, name string) Builder {
	path := fmt.Sprintf("/api/user-limits/%v/%v", url.PathEscape(user), url.PathEscape(name))
	return Request().Method(http.MethodDelete).Path(path)
}

// Details of the currently authenticated user.
// GET /api/whoami
func GetWhoami() Builder {
	path := "/api/whoami"
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all permissions for all users.
// GET /api/permissions
func GetPermissions() Builder {
	path := "/api/permissions"
	return Request().Method(http.MethodGet).Path(path)
}

// An individual permission of a user and virtual host. To PUT a permission, you will need a body looking something like this:
// {"configure":".*","write":".*","read":".*"}
// All keys are mandatory.
// GET /api/permissions/{vhost}/{user}
func GetPermissionsForVhostAndUser(vhost string, user string) Builder {
	path := fmt.Sprintf("/api/permissions/%v/%v", url.PathEscape(vhost), url.PathEscape(user))
	return Request().Method(http.MethodGet).Path(path)
}

// An individual permission of a user and virtual host. To PUT a permission, you will need a body looking something like this:
// {"configure":".*","write":".*","read":".*"}
// All keys are mandatory.
// PUT /api/permissions/{vhost}/{user}
func PutPermissionsForVhostAndUser(vhost string, user string) Builder {
	path := fmt.Sprintf("/api/permissions/%v/%v", url.PathEscape(vhost), url.PathEscape(user))
	return Request().Method(http.MethodPut).Path(path)
}

// An individual permission of a user and virtual host. To PUT a permission, you will need a body looking something like this:
// {"configure":".*","write":".*","read":".*"}
// All keys are mandatory.
// DELETE /api/permissions/{vhost}/{user}
func DeletePermissionsForVhostAndUser(vhost string, user string) Builder {
	path := fmt.Sprintf("/api/permissions/%v/%v", url.PathEscape(vhost), url.PathEscape(user))
	return Request().Method(http.MethodDelete).Path(path)
}

// A list of all topic permissions for all users.
// GET /api/topic-permissions
func GetTopicPermissions() Builder {
	path := "/api/topic-permissions"
	return Request().Method(http.MethodGet).Path(path)
}

// Topic permissions for a user and virtual host. To PUT a topic permission, you will need a body looking something like this:
// {"exchange":"amq.topic","write":"^a","read":".*"}
// All keys are mandatory.
// GET /api/topic-permissions/{vhost}/{user}
func GetTopicPermissionsForVhostAndUser(vhost string, user string) Builder {
	path := fmt.Sprintf("/api/topic-permissions/%v/%v", url.PathEscape(vhost), url.PathEscape(user))
	return Request().Method(http.MethodGet).Path(path)
}

// Topic permissions for a user and virtual host. To PUT a topic permission, you will need a body looking something like this:
// {"exchange":"amq.topic","write":"^a","read":".*"}
// All keys are mandatory.
// PUT /api/topic-permissions/{vhost}/{user}
func PutTopicPermissionsForVhostAndUser(vhost string, user string) Builder {
	path := fmt.Sprintf("/api/topic-permissions/%v/%v", url.PathEscape(vhost), url.PathEscape(user))
	return Request().Method(http.MethodPut).Path(path)
}

// Topic permissions for a user and virtual host. To PUT a topic permission, you will need a body looking something like this:
// {"exchange":"amq.topic","write":"^a","read":".*"}
// All keys are mandatory.
// DELETE /api/topic-permissions/{vhost}/{user}
func DeleteTopicPermissionsForVhostAndUser(vhost string, user string) Builder {
	path := fmt.Sprintf("/api/topic-permissions/%v/%v", url.PathEscape(vhost), url.PathEscape(user))
	return Request().Method(http.MethodDelete).Path(path)
}

// A list of all vhost-scoped parameters.
// GET /api/parameters
func GetParameters() Builder {
	path := "/api/parameters"
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all vhost-scoped parameters for a given component.
// GET /api/parameters/{component}
func GetParameters2(component string) Builder {
	path := fmt.Sprintf("/api/parameters/%v", url.PathEscape(component))
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all vhost-scoped parameters for a given component and virtual host.
// GET /api/parameters/{component}/{vhost}
func GetParametersForComponentAndVhost(component string, vhost string) Builder {
	path := fmt.Sprintf("/api/parameters/%v/%v", url.PathEscape(component), url.PathEscape(vhost))
	return Request().Method(http.MethodGet).Path(path)
}

// An individual vhost-scoped parameter. To PUT a parameter, you will need a body looking something like this:
// {"vhost": "/","component":"federation","name":"local_username","value":"guest"}
// GET /api/parameters/{component}/{vhost}/{name}
func GetParameterForComponentAndVhost(component string, vhost string, name string) Builder {
	path := fmt.Sprintf("/api/parameters/%v/%v/%v", url.PathEscape(component), url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodGet).Path(path)
}

// An individual vhost-scoped parameter. To PUT a parameter, you will need a body looking something like this:
// {"vhost": "/","component":"federation","name":"local_username","value":"guest"}
// PUT /api/parameters/{component}/{vhost}/{name}
func PutParameterForComponentAndVhost(component string, vhost string, name string) Builder {
	path := fmt.Sprintf("/api/parameters/%v/%v/%v", url.PathEscape(component), url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodPut).Path(path)
}

// An individual vhost-scoped parameter. To PUT a parameter, you will need a body looking something like this:
// {"vhost": "/","component":"federation","name":"local_username","value":"guest"}
// DELETE /api/parameters/{component}/{vhost}/{name}
func DeleteParameterForComponentAndVhost(component string, vhost string, name string) Builder {
	path := fmt.Sprintf("/api/parameters/%v/%v/%v", url.PathEscape(component), url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodDelete).Path(path)
}

// A list of all global parameters.
// GET /api/global-parameters
func GetGlobalParameters() Builder {
	path := "/api/global-parameters"
	return Request().Method(http.MethodGet).Path(path)
}

// An individual global parameter. To PUT a parameter, you will need a body looking something like this:
// {"name":"user_vhost_mapping","value":{"guest":"/","rabbit":"warren"}}
// GET /api/global-parameters/{name}
func GetGlobalParameter(name string) Builder {
	path := fmt.Sprintf("/api/global-parameters/%v", url.PathEscape(name))
	return Request().Method(http.MethodGet).Path(path)
}

// An individual global parameter. To PUT a parameter, you will need a body looking something like this:
// {"name":"user_vhost_mapping","value":{"guest":"/","rabbit":"warren"}}
// PUT /api/global-parameters/{name}
func PutGlobalParameter(name string) Builder {
	path := fmt.Sprintf("/api/global-parameters/%v", url.PathEscape(name))
	return Request().Method(http.MethodPut).Path(path)
}

// An individual global parameter. To PUT a parameter, you will need a body looking something like this:
// {"name":"user_vhost_mapping","value":{"guest":"/","rabbit":"warren"}}
// DELETE /api/global-parameters/{name}
func DeleteGlobalParameter(name string) Builder {
	path := fmt.Sprintf("/api/global-parameters/%v", url.PathEscape(name))
	return Request().Method(http.MethodDelete).Path(path)
}

// A list of all policies in a given virtual host.
// GET /api/policies/{vhost}
func GetPoliciesForVhost(vhost string) Builder {
	path := fmt.Sprintf("/api/policies/%v", url.PathEscape(vhost))
	return Request().Method(http.MethodGet).Path(path)
}

// An individual policy. To PUT a policy, you will need a body looking something like this:
// {"pattern":"^amq.", "definition": {"federation-upstream-set":"all"}, "priority":0, "apply-to": "all"}
// pattern and definition are mandatory, priority and apply-to are optional.
// GET /api/policies/{vhost}/{name}
func GetPolicyForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/policies/%v/%v", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodGet).Path(path)
}

// An individual policy. To PUT a policy, you will need a body looking something like this:
// {"pattern":"^amq.", "definition": {"federation-upstream-set":"all"}, "priority":0, "apply-to": "all"}
// pattern and definition are mandatory, priority and apply-to are optional.
// PUT /api/policies/{vhost}/{name}
func PutPolicyForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/policies/%v/%v", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodPut).Path(path)
}

// An individual policy. To PUT a policy, you will need a body looking something like this:
// {"pattern":"^amq.", "definition": {"federation-upstream-set":"all"}, "priority":0, "apply-to": "all"}
// pattern and definition are mandatory, priority and apply-to are optional.
// DELETE /api/policies/{vhost}/{name}
func DeletePolicyForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/policies/%v/%v", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodDelete).Path(path)
}

// A list of all operator policy overrides.
// GET /api/operator-policies
func GetOperatorPolicies() Builder {
	path := "/api/operator-policies"
	return Request().Method(http.MethodGet).Path(path)
}

// A list of all operator policy overrides in a given virtual host.
// GET /api/operator-policies/{vhost}
func GetOperatorPoliciesForVhost(vhost string) Builder {
	path := fmt.Sprintf("/api/operator-policies/%v", url.PathEscape(vhost))
	return Request().Method(http.MethodGet).Path(path)
}

// An individual operator policy. To PUT a policy, you will need a body looking something like this:
// {"pattern":"^amq.", "definition": {"expires":100}, "priority":0, "apply-to": "queues"}
// pattern and definition are mandatory, priority and apply-to are optional.
// GET /api/operator-policies/{vhost}/{name}
func GetOperatorPolicyForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/operator-policies/%v/%v", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodGet).Path(path)
}

// An individual operator policy. To PUT a policy, you will need a body looking something like this:
// {"pattern":"^amq.", "definition": {"expires":100}, "priority":0, "apply-to": "queues"}
// pattern and definition are mandatory, priority and apply-to are optional.
// PUT /api/operator-policies/{vhost}/{name}
func PutOperatorPolicyForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/operator-policies/%v/%v", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodPut).Path(path)
}

// An individual operator policy. To PUT a policy, you will need a body looking something like this:
// {"pattern":"^amq.", "definition": {"expires":100}, "priority":0, "apply-to": "queues"}
// pattern and definition are mandatory, priority and apply-to are optional.
// DELETE /api/operator-policies/{vhost}/{name}
func DeleteOperatorPolicyForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/operator-policies/%v/%v", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodDelete).Path(path)
}

// Declares a test queue on the target node, then publishes and consumes a
// message. Intended to be used as a very basic health check.
// Responds a 200 OK if the check succeeded,
// otherwise responds with a 503 Service Unavailable.
// GET /api/aliveness-test/{vhost}
func GetAlivenessTestForVhost(vhost string) Builder {
	path := fmt.Sprintf("/api/aliveness-test/%v", url.PathEscape(vhost))
	return Request().Method(http.MethodGet).Path(path)
}

// Responds a 200 OK if there are no alarms in effect in the cluster,
// otherwise responds with a 503 Service Unavailable.
// GET /api/health/checks/alarms
func GetHealthChecksAlarms() Builder {
	path := "/api/health/checks/alarms"
	return Request().Method(http.MethodGet).Path(path)
}

// Responds a 200 OK if there are no local alarms in effect on the target node,
// otherwise responds with a 503 Service Unavailable.
// GET /api/health/checks/local-alarms
func GetHealthChecksLocalAlarms() Builder {
	path := "/api/health/checks/local-alarms"
	return Request().Method(http.MethodGet).Path(path)
}

// Checks the expiration date on the certificates for every listener configured to use TLS.
// Responds a 200 OK if all certificates are valid (have not expired),
// otherwise responds with a 503 Service Unavailable.
// Valid units: days, weeks, months, years. The value of the {within} argument is the number of
// units. So, when {within} is 2 and {unit} is "months", the expiration period used by the check
// will be the next two months.
// GET /api/health/checks/certificate-expiration/{within}/{unit}
func GetHealthChecksCertificateExpirationForWithinAndUnit(within int, unit string) Builder {
	path := fmt.Sprintf("/api/health/checks/certificate-expiration/%v/%v", within, url.PathEscape(unit))
	return Request().Method(http.MethodGet).Path(path)
}

// Responds a 200 OK if there is an active listener on the give port,
// otherwise responds with a 503 Service Unavailable.
// GET /api/health/checks/port-listener/{port}
func GetHealthChecksPortListener(port int) Builder {
	path := fmt.Sprintf("/api/health/checks/port-listener/%v", port)
	return Request().Method(http.MethodGet).Path(path)
}

// Responds a 200 OK if there is an active listener for the given protocol,
// otherwise responds with a 503 Service Unavailable. Valid protocol names are: amqp091, amqp10, mqtt, stomp, web-mqtt, web-stomp.
// GET /api/health/checks/protocol-listener/{protocol}
func GetHealthChecksProtocolListener(protocol string) Builder {
	path := fmt.Sprintf("/api/health/checks/protocol-listener/%v", url.PathEscape(protocol))
	return Request().Method(http.MethodGet).Path(path)
}

// Responds a 200 OK if all virtual hosts and running on the target node,
// otherwise responds with a 503 Service Unavailable.
// GET /api/health/checks/virtual-hosts
func GetHealthChecksVirtualHosts() Builder {
	path := "/api/health/checks/virtual-hosts"
	return Request().Method(http.MethodGet).Path(path)
}

// Checks if there are classic mirrored queues without synchronised mirrors online
// (queues that would potentially lose data if the target node is shut down).
// Responds a 200 OK if there are no such classic mirrored queues,
// otherwise responds with a 503 Service Unavailable.
// GET /api/health/checks/node-is-mirror-sync-critical
func GetHealthChecksNodeIsMirrorSyncCritical() Builder {
	path := "/api/health/checks/node-is-mirror-sync-critical"
	return Request().Method(http.MethodGet).Path(path)
}

// Checks if there are quorum queues with minimum online quorum (queues that
// would lose their quorum and availability if the target node is shut down).
// Responds a 200 OK if there are no such quorum queues,
// otherwise responds with a 503 Service Unavailable.
// GET /api/health/checks/node-is-quorum-critical
func GetHealthChecksNodeIsQuorumCritical() Builder {
	path := "/api/health/checks/node-is-quorum-critical"
	return Request().Method(http.MethodGet).Path(path)
}

// Lists per-vhost limits for all vhosts.
// GET /api/vhost-limits
func GetVhostLimits() Builder {
	path := "/api/vhost-limits"
	return Request().Method(http.MethodGet).Path(path)
}

// Lists per-vhost limits for specific vhost.
// GET /api/vhost-limits/{vhost}
func GetVhostLimitsForVhost(vhost string) Builder {
	path := fmt.Sprintf("/api/vhost-limits/%v", url.PathEscape(vhost))
	return Request().Method(http.MethodGet).Path(path)
}

// Set or delete per-vhost limit for vhost. The name URL path element
// refers to the name of the limit (max-connections, max-queues).
// Limits are set using a JSON document in the body: {"value": 100}. Example
// request:
// curl -4u 'guest:guest' -H 'content-type:application/json' -X PUT localhost:15672/api/vhost-limits/my-vhost/max-connections -d '{"value": 50}'
// PUT /api/vhost-limits/{vhost}/{name}
func PutVhostLimitForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/vhost-limits/%v/%v", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodPut).Path(path)
}

// Set or delete per-vhost limit for vhost. The name URL path element
// refers to the name of the limit (max-connections, max-queues).
// Limits are set using a JSON document in the body: {"value": 100}. Example
// request:
// curl -4u 'guest:guest' -H 'content-type:application/json' -X PUT localhost:15672/api/vhost-limits/my-vhost/max-connections -d '{"value": 50}'
// DELETE /api/vhost-limits/{vhost}/{name}
func DeleteVhostLimitForVhost(vhost string, name string) Builder {
	path := fmt.Sprintf("/api/vhost-limits/%v/%v", url.PathEscape(vhost), url.PathEscape(name))
	return Request().Method(http.MethodDelete).Path(path)
}

// Details about the OAuth2 configuration. It will return HTTP
// status 200 with body: {"enable_uaa":"boolean", "uaa_client_id":"string", "uaa_location":"string"}
// GET /api/auth
func GetAuth() Builder {
	path := "/api/auth"
	return Request().Method(http.MethodGet).Path(path)
}

// Rebalances all queues in all vhosts. This operation  is asynchronous therefore please check
// the RabbitMQ log file for messages regarding the success or failure of the operation.
// curl -4u 'guest:guest' -XPOST localhost:15672/api/rebalance/queues/
// POST /api/rebalance/queues
func PostRebalanceQueues() Builder {
	path := "/api/rebalance/queues"
	return Request().Method(http.MethodPost).Path(path)
}

// Provides status for all federation links. Requires the rabbitmq_federation_management plugin to be enabled.
// GET /api/federation-links
func GetFederationLinks() Builder {
	path := "/api/federation-links"
	return Request().Method(http.MethodGet).Path(path)
}

// Provides status for all federation links. Requires the rabbitmq_federation_management plugin to be enabled.
// GET /api/federation-links/{vhost}
func GetFederationLinksForVhost(vhost string) Builder {
	path := fmt.Sprintf("/api/federation-links/%v", url.PathEscape(vhost))
	return Request().Method(http.MethodGet).Path(path)
}

// A list of authentication attempts.
// GET /api/auth/attempts/{node}
func GetAuthAttempts(node string) Builder {
	path := fmt.Sprintf("/api/auth/attempts/%v", url.PathEscape(node))
	return Request().Method(http.MethodGet).Path(path)
}

// A list of authentication attempts.
// DELETE /api/auth/attempts/{node}
func DeleteAuthAttempts(node string) Builder {
	path := fmt.Sprintf("/api/auth/attempts/%v", url.PathEscape(node))
	return Request().Method(http.MethodDelete).Path(path)
}

// A list of authentication attempts by remote address and username.
// GET /api/auth/attempts/{node}/source
func GetAuthAttemptsSource(node string) Builder {
	path := fmt.Sprintf("/api/auth/attempts/%v/source", url.PathEscape(node))
	return Request().Method(http.MethodGet).Path(path)
}

// A list of authentication attempts by remote address and username.
// DELETE /api/auth/attempts/{node}/source
func DeleteAuthAttemptsSource(node string) Builder {
	path := fmt.Sprintf("/api/auth/attempts/%v/source", url.PathEscape(node))
	return Request().Method(http.MethodDelete).Path(path)
}

